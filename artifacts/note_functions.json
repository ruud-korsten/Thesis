{
  "Unusually high frequency of a single InvoiceNo might indicate data entry errors or duplicate transactions.": "def check_unusually_high_invoice_frequency(df):\n    invoice_counts = df['InvoiceNo'].value_counts()\n    high_frequency_invoices = invoice_counts[invoice_counts > 1].index\n    return df['InvoiceNo'].isin(high_frequency_invoices)",
  "High frequency of certain StockCodes should be reviewed for potential errors or popular items.": "def check_high_frequency_stockcode(df):\n    stockcode_counts = df['StockCode'].value_counts()\n    high_frequency_stockcodes = stockcode_counts[stockcode_counts > stockcode_counts.quantile(0.95)].index\n    return df['StockCode'].isin(high_frequency_stockcodes)",
  "Negative Quantity values would be implausible unless indicating returns, which should be clearly documented.": "def check_negative_quantity_without_returns(df):\n    return (df['Quantity'] < 0) & ~df['Description'].str.contains('return', case=False, na=False)",
  "Extremely high Quantity values should be flagged for verification, as they might indicate data entry errors.": "def flag_high_quantity_values(df):\n    return df['Quantity'].astype(float) > 1000",
  "Unusual InvoiceDate timestamps (e.g., transactions outside business hours) should be reviewed.": "def check_unusual_invoicedate_timestamps(df):\n    business_hours_start = 9\n    business_hours_end = 17\n    inv_time = df['InvoiceDate'].dt.hour\n    return (inv_time < business_hours_start) | (inv_time >= business_hours_end)",
  "UnitPrice significantly higher or lower than typical market values should be flagged for review.": "def flag_unit_price_outliers(df):\n    unit_price = pd.to_numeric(df['UnitPrice'], errors='coerce')\n    median = unit_price.median()\n    deviation = unit_price.std()\n    lower_bound = median - 3 * deviation\n    upper_bound = median + 3 * deviation\n    return (unit_price < lower_bound) | (unit_price > upper_bound)",
  "Extremely low or high UnitPrice might indicate data entry errors or special promotions.": "def check_extreme_unit_price(df):\n    return (df['UnitPrice'].astype(float) < 0.01) | (df['UnitPrice'].astype(float) > 1000)",
  "Duplicate CustomerIDs should be reviewed to ensure they represent the same entity.": "def check_duplicate_customer_ids(df):\n    return df['CustomerID'].duplicated(keep=False)",
  "Uncommon country names should be checked for spelling errors or incorrect entries.": "def check_uncommon_country_names(df):\n    common_countries = [\n        'United Kingdom', 'Germany', 'France', 'Spain', 'Netherlands',\n        'Belgium', 'Switzerland', 'Portugal', 'Australia', 'Italy',\n        'Norway', 'Sweden', 'Japan', 'Poland', 'Ireland', 'Finland'\n    ]\n    return ~df['Country'].isin(common_countries)",
  "InvoiceDate should fall within the range of expected business operation dates.": "def check_invoice_date_within_business_operation(df):\n    expected_start_date = pd.to_datetime(\"2010-12-01\")\n    expected_end_date = pd.to_datetime(\"2011-12-31\")\n    return ~((df['InvoiceDate'] >= expected_start_date) & (df['InvoiceDate'] <= expected_end_date))"
}